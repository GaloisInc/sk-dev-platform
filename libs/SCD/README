SCD: Haskell library for Security Configuration DSL.

Depends on 
  ghc >= 6.10.1
  cabal >= 1.2.2.0
  alex (2.1.0 works)
  happy (1.17 works)
  haddock (0.8 works)
  bnfc (the latest snapshot works:
        darcs get --partial http://code.haskell.org/bnfc/ls)
  symbolic-io

To build and install:
    make install

To run the regression tests:
    make test

The libraries and regression test program can be built with profiling
support.  The specific profile is controlled by assigning appropriate
RTS flags to the Make variable PROFILING.  For example, for a standard
constructor heap profile, do

  make test PROFILING=-hy
  hp2ps -c All

Then, view the PostScript file All.ps.

The shrimp tool
~~~~~~~~~~~~~~~

There is a command "shrimp" that can be used to perform checks on a
reference policy, and to generate HTML documentation with kind
information.

Suppose the reference policy is in a directory
"Reference-Policy/refpolicy".  Also, suppose that the reference
policy's corenetwork.{te,if} files have been generated by "make -C
Reference-Policy/refpolicy conf".

Then, the command

  shrimp kindcheck Reference-Policy/refpolicy

will output a number of errors found with the policy.  The output
starts with statistics, where the first error of each type is printed,
together with how many occurrences of that type of error there are.
This gives an overview of the types of errors the tool found in the
policy.  The list is ordered so that the most frequent error type
comes first.

After that, the full list of errors follows.

The formatting of errors is suitable for execution as a compilation
command inside Emacs, because then the errors are parsed so that one
easily can get to the source code.  This assumes that the following
elisp code is added to ~/.emacs:

; shrimp error messages
(require 'compile)
(add-to-list 'compilation-error-regexp-alist
             '(" (\\([^ \n\t()]+\\):\\([0-9]+\\)/\\([0-9]+\\))" 1 2 3 nil nil))

One can also check individual modules outside the policy.  For example,

  shrimp kindcheck Reference-Policy/refpolicy myapp.te

will analyze myapp.te, myapp.if and myapp.fc in the context of the
given reference policy.

HTML generation is carried out by first creating a directory in which
the HTML files should be written.  Suppose this is "output".  Then,
the command

  shrimp html Reference-Policy/refpolicy output

generates the HTML files, and they can be browsed by starting at
output/index.html.

By passing the flag --implicit-require to shrimp, symbols are treated
as implicitly imported by require blocks, so no warnings will be
generated due to missing requires.

shrimp has a list of known macro identifiers used in ifdef statements
in the reference policy.  If it sees an identifier not in this list,
it will complain.  It is possible to replace this built-in list by
passing the arguments --ifdefs <file>, where the following is an
example of <file>:

  gen_ifdef(enable_mls)
  gen_ifdef(enable_mcs)
  gen_ifdef(distro_rhel4)
  gen_ifdef(distro_redhat)
  gen_ifdef(distro_debian)
  gen_ifdef(distro_gentoo)
  gen_ifdef(distro_suse)
  gen_ifdef(distro_ubuntu)
  gen_ifdef(targeted_policy)
  gen_ifdef(direct_sysadm_daemon)
  gen_ifdef(hide_broken_symptoms)
  gen_ifdef(TODO, false)

This tells shrimp about a number of identifiers to expect in ifdef
statements.  It is also possible through the optional second argument
to gen_ifdef to state that the identifier should be treated as defined
(true) or undefined (false).  That would make shrimp ignore the
relevant ifdef else branches or then branches, respectively.  As a
result of that, the above configuration (and indeed the built-in
configuration) shrimp ignores policy code within ifdef(`TODO',...).

The lobster tool
~~~~~~~~~~~~~~~~

There is a command "lobster" that compiles a lobster policy to the
SELinux native policy language. Its usage is simple:

  lobster [-I include.lsr] input.lsr ...
    -I include.lsr  --include=include.lsr  Include a lobster file

The lobster command takes as input a collection of lobster policy
files and compiles them into SELinux type enforcement and file context
native policy statements. Some of the input files can be tagged as
"include" files using the -I option. In the current version of the
lobster compiler these files are treated exactly the same as the other
input files - the option is present to support a future version of the
lobster compiler which outputs an SELinux reference policy module. [It
is intended that include files will be used for checking the
consistency of the input lobster policy, but will not contribute to
the resulting SELinux policy module.]

For example, consider the simple Lobster policy file example1.lsr:

  class Process {
    port active : {position = subject};
  }

  class File(filenameRegex) {
    port read : {input = 1, output = 10, position = object};
    port write : {input = 10, output = 1, position = object};
  }

  class ExampleApp(dataFilenameRegexp) {
    p = new "" Process;
    f = new "data" File(dataFilenameRegexp);
    p.active <-- f.read;
    p.active --> f.write;
  }

  app = new "example" ExampleApp("/tmp/example.*");

Running the command

  lobster example1.lsr

results in the output

  --- Type enforcement (.te) file ---
  policy_module(example1,1.0)
  type example_t;
  type example_data_t;
  allow example_t example_data_t:file read;
  allow example_t example_data_t:file write;
  --- File context (.fc) file ---
  example_data_t "/tmp/example.*"

showing the generated type enforcement and file context SELinux
statements. [Again, the prototype nature of the tool is apparent here.
The file context statements do not have the correct syntax, and a
later version of the tool would output to separate type enforcement
and file context files instead of mixing the output in this fashion.]
